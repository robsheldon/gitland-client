#!/usr/bin/php
<?php

//  https://github.com/programical/gitland

include __DIR__ . '/config';

//  Valid available moves.
$moves = ['up' => true, 'down' => true, 'left' => true, 'right' => true];


/******************************************************************************
*                                                                             *
*   Map class.                                                                *
*                                                                             *
*   Stores, parses, returns map-related information.                          *
*                                                                             *
******************************************************************************/

class Map
{

    private static $_map = [];
    private static $_current = [
        'x'     => 0,
        'y'     => 0,
        'color' => '',
    ];
    private static $_last_move = '';


    /**
     * Load the game map.
     *
     * @param   string      $game_path
     *
     * @return  void
     */
    public static function load ($game_path)
    {
        $map_file = @fopen($game_path . '/map', 'r');
        if ( is_resource($map_file) ) {
            while ( ! empty($line = trim(fgets($map_file))) ) {
                static::$_map[] = array_map('trim', explode(',', $line));
            }
            fclose($map_file);
        }
        //  Read the current position.
        $player_name = config::PLAYER_NAME;
        static::$_current = [
            'x' => trim(file_get_contents("$game_path/players/$player_name/x")),
            'y' => trim(file_get_contents("$game_path/players/$player_name/y")),
            'color' => substr(trim(file_get_contents("$game_path/players/$player_name/team")), 1, 1),
        ];
        if ( strlen(static::$_current['x']) == 0 || strlen(static::$_current['y']) == 0 ) {
            echo "ERROR: Invalid position!\n";
            stop();
        }
        static::$_last_move = trim(file_get_contents(config::CLIENT_BASE_DIR . '/act'));
    }


    /**
     * Return the size of the map in x and y dimensions.
     *
     * @return  array
     */
    public static function size ()
    {
        return ['y' => count(static::$_map), 'x' => count(static::$_map[0])];
    }


    /**
     * Return the map value stored at a given position or null if that position
     * is not valid.
     *
     * @param   int         $x
     * @param   int         $y
     *
     * @return  string
     */
    public static function get ($x, $y = null)
    {
        if ( is_array($x) ) {
            $y = $x[1];
            $x = $x[0];
        }
        if ( is_null($x) || is_null($y) || $y < 0 || $y >= count(static::$_map) || $x < 0 || $x >= count(static::$_map[$y]) ) {
            return null;
        }
        return static::$_map[$y][$x];
    }


    /**
     * Return a count of the number of $search occurrences in the map.
     *
     * @param   string      $search
     *
     * @return  integer
     */
    public static function count ($search)
    {
        $count = 0;
        $n = count(static::$_map);
        for ( $i=0; $i < $n; $i++ ) { 
            $row = array_count_values(static::$_map[$i]);
            if ( array_key_exists($search, $row) ) {
                $count += $row[$search];
            }
        }
        return $count;
    }


    /**
     * Given a direction and x, y coordinates, return a new pair of x, y
     * coordinates in that direction.
     *
     * @param   string      $direction
     * @param   int         $x
     * @param   int         $y
     * 
     * @return  array
     */
    public static function translate ($direction, $x, $y)
    {
        switch ($direction) {
            case 'left':
                return [--$x, $y];
            case 'right':
                return [++$x, $y];
            case 'up':
                return [$x, --$y];
            case 'down':
                return [$x, ++$y];
            case 'idle':
                return [$x, $y];
        }
        return [$x, $y];
    }


    /**
     * Return the opposite of a given direction.
     *
     * @param   string      $direction
     * 
     * @return  string
     */
    public static function opposite ($direction)
    {
        switch ($direction) {
            case 'left':
                return 'right';
            case 'right':
                return 'left';
            case 'up':
                return 'down';
            case 'down':
                return 'up';
        }
        echo "Invalid direction: $direction\n";
        stop();
    }


    /**
     * Return the bot's current x, y, or color value.
     *
     * @param   string      $key
     * 
     * @return  mixed
     */
    function current ($key)
    {
        return static::$_current[$key];
    }


    /**
     * Return the bot's most recent move.
     *
     * @return  string
     */
    function last_move ()
    {
        return static::$_last_move;
    }

}



/******************************************************************************
*                                                                             *
*   Strategy class.                                                           *
*                                                                             *
*   Contains several different situational tactics and returns the best       *
*   available move depending on the conditions.                               *
*                                                                             *
******************************************************************************/

class Strategy
{

    static private $_weight = 16;


    /**
     * Calculate a value for moving to a specific position on the map.
     * A weighting factor can be provided to adjust scores by distance
     * from the current position.
     * Enemy colors return higher scores, while own color and other players
     * return lower scores.
     *
     * @param   int         $x
     * @param   int         $y
     * @param   double      $weight
     *
     * @return  double
     */
    public static function score ($x, $y, $weight = 1)
    {
        $location = Map::get($x, $y);
        if ( is_null($location) ) {
            return 0;
        }
        if ( substr($location, 0, 1) == 'c' ) {
            //  Strongly avoid other players.
            return -5 * $weight;
        }
        if ( substr($location, 1, 1) != Map::current('color') ) {
            //  Try to stomp on other colors.
            return 1.5 * $weight;
        }
        else {
            //  Avoid red areas.
            return -2 * $weight;
        }
        return 0;
    }


    /**
     * Given a direction, current x, y coordinates, the current weighting factor,
     * and the spread distance, return a cumulative score for all squares along
     * that line.
     * 
     * @param   string      $direction
     * @param   int         $x
     * @param   int         $y
     * @param   double      $weight
     * @param   int         $spread
     * 
     * @return  double
     */
    public static function area_score ($direction, $x, $y, $weight, $spread)
    {
        $score = 0;
        $n = -1 * $spread;
        switch ($direction) {
            case 'left':
            case 'right':
                //  If going left or right, then spread vertically.
                while ( $n <= $spread ) {
                    $score += static::score($x, $y + $n, $weight / 2);
                    $n++;
                }
                break;
            case 'up':
            case 'down':
                //  If going up or down, then spread horizontally.
                while ( $n <= $spread ) {
                    $score += static::score($x + $n, $y, $weight / 2);
                    $n++;
                }
                break;
        }
        return $score;
    }


    /**
     * Calculate a score for each possible move and return the highest-scoring move.
     *
     * @return  string
     */
    public static function evaluate_moves ($moves)
    {
        $scores = [];
        foreach ($moves as $direction => $value) {
            $scores[$direction] = 0;
            $x = Map::current('x');
            $y = Map::current('y');
            $weight = 16;
            $score = 0;
            $spread = 0;
            $lookahead_iteration = 0;
            while ( true ) {
                $lookahead_iteration++;
                //  Expand the lookahead beam a bit.
                if ( $lookahead_iteration % 2 != 0 ) {
                    $spread++;
                }
                //  Adjust weighting for distance from current position.
                $weight /= 2;
                //  Transform coordinates.
                list($x, $y) = Map::translate($direction, $x, $y);
                //  Calculate scores in this direction.
                $score = static::score($x, $y, $weight);
                if ( $score === 0 ) {
                    //  score() returns exactly 0 if the coordinates are not valid.
                    break;
                }
                //  If this direction is the opposite of the last direction, brutally
                //  penalize it to prevent oscillations.
                if ( Map::last_move() != 'idle' && $direction == Map::opposite(Map::last_move()) ) {
                    $score -= $weight;
                }
                //  Calculate the final score for this iteration of this direction.
                $scores[$direction] += ($score + static::area_score($direction, $x, $y, $weight, $spread));
            }
        }
        arsort($scores);
        return $scores;
    }


    /**
     * The "stuck" strategy, intended for situations where the bot has very
     * limited options available.
     *
     * @param   array       $available_moves
     *
     * @return  array
     */
    public static function stuck ($available_moves)
    {
        if ( count($available_moves) == 1 ) {
            $direction = array_keys($available_moves)[0];
            return ['move' => $direction, 'logmsg' => "stuck; $direction; @" . Map::current('x') . "," . Map::current('y')];
        }
        return ['move' => 'idle', 'logmsg' => "stuck; idle; @" . Map::current('x') . "," . Map::current('y')];
    }


    /**
     * The "cruise" strategy. This uses scorebeam-based move evaluation, but
     * will keep the bot moving in the same direction as long as that direction
     * returns a positive score. This is a friendlier movement pattern that
     * doesn't chew up the board as badly as the aggressive default pattern.
     *
     * @param  array        $available_moves
     *
     * @return array
     */
    public static function cruise ($available_moves)
    {
        $scores = Strategy::evaluate_moves($available_moves);
        var_dump($scores);
        if ( array_key_exists(Map::last_move(), $scores) && $scores[Map::last_move()] > 0 ) {
            return ['move' => Map::last_move(), 'logmsg' => "cruise; " . Map::last_move() . "; @" . Map::current('x') . "," . Map::current('y')];
        }
        //  This direction is no longer valid or is negatively scored.
        return ['move' => array_keys($scores)[0], 'logmsg' => "cruise; " . array_keys($scores)[0] . "; @" . Map::current('x') . "," . Map::current('y')];
    }


    /**
     * The "aggressive" (default) strategy. This uses scorebeam-based move
     * evaluation and the bot will aggressively pursue the highest available
     * score from its current position.
     *
     * @param  array        $available_moves
     *
     * @return array
     */
    public static function aggressive ($available_moves)
    {
        $scores = Strategy::evaluate_moves($available_moves);
        return ['move' => array_keys($scores)[0], 'logmsg' => "aggressive; $direction; @" . Map::current('x') . "," . Map::current('y')];
    }


    /**
     * Return a direction and a commit message depending on the current game
     * situation.
     *
     * @return  array
     */
    public static function find_move ()
    {
        $commands = config::VALID_MOVES;
        //  Retrieve coordinates for available moves from the current map.
        //  Any invalid moves will get set to null.
        $available_moves = [];
        foreach ($commands as $command) {
            $available_moves[$command] = Map::get(Map::translate($command, Map::current('x'), Map::current('y')));
        }
        //  Remove invalid directions -- edges of map and any adjacent tiles
        //  containing another bot (and, for now, the "idle" command too).
        unset($available_moves['idle']);
        $available_moves = array_filter($available_moves, function($move){
            if ( is_null($move) || substr($move, 0, 1) == 'c' ) {
                return false;
            }
            return true;
        });
        //  For now, let's continue this helpful debugging output. TODO.
        print_r($available_moves);
        //  Select a strategy.
        if ( count($available_moves) < 2 ) {
            //  Fall back to the "stuck" strategy; escape in any available direction.
            //  In the future, the bot may try to teleport from this location.
            return static::stuck($available_moves);
        }
        if ( Map::count('ux') > array_product(Map::size()) * .2 ) {
            //  If more than 20% of the tiles on the map are unclaimed, then
            //  select a friendlier, less aggressive movement pattern.
            return static::cruise($available_moves);
        }
        //  Default strategy: best available move.
        return static::aggressive($available_moves);
    }

}



/**
 * Write a null move to the act file and halt.
 *
 * @return  void
 */
function stop ()
{
    file_put_contents(config::CLIENT_BASE_DIR . '/act', 'idle');
    die();
}


//  Try to avoid missing the latest update from the server.
sleep(10);

//  Get the current game situation.
echo "Retrieving updates...\n";
exec('cd ' . config::GAME_BASE_DIR . ' && git pull', $out);

//  Read the current game board.
Map::load(config::GAME_BASE_DIR);

echo "Current position: " . Map::current('x') . ", " . Map::current('y') . "\n";
echo "Current team: " . Map::current('color') . "\n";
echo "Last move was: " . Map::last_move() . "\n";

$this_turn = Strategy::find_move();

if ( $this_turn['move'] == Map::last_move() ) {
    echo "Current move is same as last, skipping commit.\n";
}
else {
    //  Write the move.
    file_put_contents(config::CLIENT_BASE_DIR . '/act', $this_turn['move']);
    $out = [];
    exec('cd ' . config::CLIENT_BASE_DIR . " && git add act && git commit -m '" . $this_turn['logmsg'] . "' && git push", $out);
    print_r($out);
}
